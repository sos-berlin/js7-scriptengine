# Example of calling a CPython application that cannot be loaded/executed directly via the GraalVM Polyglot interface.
# 
# For Variant 2, in principle, a new js7Step method (e.g., js7Step.executeProcess(...)) can be introduced
# - which internally creates a Java process, handling stdout/stderr and 
#   supporting cancelable resource management.
class JS7Job(js7.Job):
    def processOrder(self, js7Step):
        #//!include Python-Logging 
        logger = js7Step.getLogger()
        import subprocess
        
        python_executable = js7Step.getAllArgumentsAsNameValueMap().get("python_executable")
        python_app = js7Step.getAllArgumentsAsNameValueMap().get("python_app")
        
        logger.info(f"[subprocess]start...") 
        # Variant 1 - wait
        #result = subprocess.run(
        #    [r"D:\Programme\Python\3.13.9\python.exe", "config/python/my_script.py", "js7Step_argument_1", "js7Step_argument_2"],
        #    [python_executable, python_app, "js7Step_argument_1", "js7Step_argument_2"],
        #    capture_output=True,
        #    text=True
        #) 
        #result = subprocess.run(['echo', '123'], stdout=open('file.txt', 'w'), capture_output=True, text=True) 
        #logger.info(f"[subprocess][returncode={result.returncode}][stderr={result.stderr.strip()}]{result.stdout.strip()}")
        #logger.info(f"[subprocess][returncode={result.returncode}][stderr={result.stderr}]{result.stdout}")  
        
        # Variant 2 : live, -u - unbuffered
        process = subprocess.Popen(
            [python_executable, "-u" ,python_app, "js7Step_argument_1", "js7Step_argument_2"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )
        js7Step.setCancelableResource(process)
        
        for line in process.stdout:
            #print(f"[LIVE STDOUT]{line.rstrip()}")
            logger.info(f"[LIVE STDOUT]{line.rstrip()}")
            

        for line in process.stderr:
            #print(f"[LIVE STDERR]{line.rstrip()}")
            logger.error(f"[LIVE STDERR]{line.rstrip()}")

        returncode = process.wait()
        logger.info(f"[subprocess]returncode={returncode}")
        
    def onProcessOrderCanceled(self, js7Step):
        #######################################################
        process = js7Step.getCancelableResource()
        #######################################################
        
        js7Step.getLogger().info(f"onProcessOrderCanceled={process}")
        if process is not None:
            # process.terminate()
            process.kill()
